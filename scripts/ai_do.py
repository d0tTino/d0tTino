#!/usr/bin/env python3
"""Interactively execute shell commands generated by ``ai_exec.plan``."""


from __future__ import annotations

import argparse
from pathlib import Path
from typing import Callable, List, Optional, Sequence
import time
import logging

from scripts import ai_exec
from llm.backends import load_backends
from scripts.cli_common import execute_steps, send_notification
from telemetry import record_event, analytics_default

load_backends()


def run_recipe(
    name: str,
    goal: str,
    steps_or_callable: Sequence[str] | Callable[[str], Sequence[str]],
    *,
    log_path: Path,
    analytics: bool = False,
) -> int:
    """Execute a recipe given steps or a callable and record an event."""
    if callable(steps_or_callable):
        steps = list(steps_or_callable(goal))
    else:
        steps = list(steps_or_callable)
    exit_code = execute_steps(steps, log_path=log_path)
    success = record_event(
        "ai-do-recipe",
        {"recipe": name, "goal": goal, "exit_code": exit_code},
        enabled=analytics,
    )
    if not success:
        logging.debug("Failed to record telemetry")
    return exit_code


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("goal", help="High level description of the task")
    parser.add_argument("--config")
    parser.add_argument("--notify", action="store_true", help="Send notification when done")
    parser.add_argument(
        "--analytics",
        action="store_true",
        help="Record anonymous usage events",
    )
    parser.add_argument(
        "--log",
        type=Path,
        default=Path("ai_do.log"),
        help="Log file path (default: %(default)s)",
    )
    args = parser.parse_args(argv)

    analytics = args.analytics or analytics_default()
    cfg_path = Path(args.config) if args.config else None
    start = time.time()
    steps = ai_exec.plan(args.goal, config_path=cfg_path, analytics=analytics)
    exit_code = execute_steps(steps, log_path=args.log)
    end = time.time()
    if args.notify:
        if exit_code == 0:
            send_notification("ai-do completed with exit code 0")
        else:
            send_notification(f"ai-do failed with exit code {exit_code}")
    success = record_event(
        "ai-do",
        {
            "goal": args.goal,
            "exit_code": exit_code,
            "duration_ms": int((end - start) * 1000),
            "model_source": "remote" if ai_exec.last_model_remote() else "local",
        },
        enabled=analytics,
    )
    if not success:
        logging.debug("Failed to record telemetry")

    return exit_code


if __name__ == "__main__":
    raise SystemExit(main())
